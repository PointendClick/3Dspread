<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Cube Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #f0f0f0;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        .action-buttons {
            position: fixed;
            top: 0.5rem;
            left: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 100;
        }
        .main-controls {
            display: flex;
            gap: 0.5rem;
        }
        .action-button {
            padding: 0.25rem 0.5rem;
            font-size: 1.5rem;
            line-height: 1;
            font-weight: bold;
            color: #fff;
            background-color: #4a4a4a;
            border-radius: 0.5rem;
            cursor: pointer;
            user-select: none;
            transition: transform 0.2s, background-color 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .action-button:hover {
            transform: scale(1.1);
        }
        .action-button.active {
            background-color: #63c5da;
        }
        .color-buttons-container {
            position: fixed;
            bottom: 0.5rem;
            left: 0.5rem;
            z-index: 100;
        }
        .controls-container {
            position: fixed;
            top: 0.5rem;
            right: 0.5rem;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            z-index: 100;
        }
        .control-button {
            padding: 0.125rem 0.25rem;
            font-size: 0.75rem;
            line-height: 1;
            font-weight: bold;
            color: #fff;
            background-color: #4a4a4a;
            border-radius: 0.5rem;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .control-button.active {
            background-color: #63c5da;
        }
        .control-button:hover {
            background-color: #6a6a6a;
        }
        .em-dash {
            font-size: 0.75rem;
        }
        .color-button {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            cursor: pointer;
            transition: border 0.2s;
            border: 2px solid transparent;
        }
        .color-button.active {
            border-color: #fff;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-200">
    <div id="container"></div>

    <div class="action-buttons">
        <div class="main-controls">
            <button id="plus-sign" class="action-button active">+</button>
            <button id="minus-sign" class="action-button"><span class="em-dash">â€”</span></button>
            <button id="clear-all" class="action-button flex justify-center items-center">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-x-circle"><circle cx="12" cy="12" r="10"/><path d="m15 9-6 6"/><path d="m9 9 6 6"/></svg>
            </button>
        </div>
    </div>
    
    <div class="controls-container">
        <button id="view-2d" class="control-button active">2D</button>
        <button id="view-3d" class="control-button">3D</button>
        <button id="zoom-in" class="control-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zoom-in"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></svg>
        </button>
        <button id="zoom-out" class="control-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-zoom-out"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="8" x2="14" y1="11" y2="11"/></svg>
        </button>
    </div>

    <div class="color-buttons-container">
        <div class="flex flex-row gap-2 mt-2">
            <button id="color-red" class="color-button" style="background-color: #FF0000;"></button>
            <button id="color-yellow" class="color-button" style="background-color: #FFFF00;"></button>
            <button id="color-blue" class="color-button" style="background-color: #0000FF;"></button>
            <button id="color-green" class="color-button" style="background-color: #00FF00;"></button>
            <button id="color-orange" class="color-button" style="background-color: #FFA500;"></button>
            <button id="color-purple" class="color-button" style="background-color: #800080;"></button>
        </div>
    </div>

    <script>
        window.onload = function() {
            // --- Scene Setup ---
            const container = document.getElementById('container');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            container.appendChild(renderer.domElement);

            // --- Cube Group and World Group ---
            const cubeContainer = new THREE.Group();
            scene.add(cubeContainer);

            const worldGroup = new THREE.Group();
            scene.add(worldGroup);

            // --- Camera and Controls ---
            const topDownCameraPosition = new THREE.Vector3(0, 50, 0);
            const default3DCameraPosition = new THREE.Vector3(15, 15, 15);
            let is2DMode = true;
            let isDraggingCamera = false;
            let previousMousePosition = {
                x: 0,
                y: 0
            };
            
            camera.position.copy(topDownCameraPosition);
            camera.lookAt(0, 0, 0);
            
            // --- Grid and Interaction Planes ---
            const gridSize = 16;
            const cubeSize = 3;
            const MAX_GRID_POS = (gridSize / 2 - 0.5) * cubeSize;
            const MAX_HEIGHT_POS = (gridSize - 0.5) * cubeSize;
            
            const gridHelper = new THREE.GridHelper(gridSize * cubeSize, gridSize, 0xaaaaaa, 0x555555);
            worldGroup.add(gridHelper);
            const planeGeometry = new THREE.PlaneGeometry(gridSize * cubeSize, gridSize * cubeSize);
            const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0 });
            const groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            groundPlane.rotation.x = -Math.PI / 2;
            worldGroup.add(groundPlane);

            // --- Cube Management ---
            const cubes = [];
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();
            let isPlacementMode = true;
            let isDeleteMode = false;
            let isDragging = false;
            let isShiftDragging = false;
            let currentCubeColor = 0x808080;
            let clipboard = null;
            let hoveredCube = null;
            const layerColorMap = new Map();
            let dragStartPoint = null;
            let lastDraggedPosition = null;

            // Ghost Cube Setup
            const ghostGeometry = new THREE.BoxGeometry(cubeSize - 0.2, cubeSize - 0.2, cubeSize - 0.2);
            const ghostPlacementMaterial = new THREE.MeshBasicMaterial({ color: 0x63c5da, transparent: true, opacity: 0.6 });
            const ghostDeleteMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3 });
            const ghostCube = new THREE.Mesh(ghostGeometry, ghostPlacementMaterial);
            ghostCube.visible = false;
            scene.add(ghostCube);

            // A collection of ghost meshes for the line preview
            const ghostLineGroup = new THREE.Group();
            scene.add(ghostLineGroup);

            let ghostCubePosition = new THREE.Vector3(cubeSize / 2, cubeSize / 2, cubeSize / 2);
            ghostCube.position.copy(ghostCubePosition);
            
            function createCube(position, color = currentCubeColor) {
                // Add a final boundary check before creating the cube
                if (Math.abs(position.x) > MAX_GRID_POS + 0.1 ||
                    Math.abs(position.z) > MAX_GRID_POS + 0.1 ||
                    position.y > MAX_HEIGHT_POS + 0.1) {
                    return;
                }

                // Check if a cube already exists at this exact position
                const isOccupied = cubes.some(c => c.mesh.position.distanceTo(position) < 0.1);
                if (isOccupied) return;

                // New logic: Check the cube directly below
                const positionBelow = position.clone();
                positionBelow.y -= cubeSize;
                const cubeBelow = cubes.find(c => c.mesh.position.distanceTo(positionBelow) < 0.1);

                // Placement on the ground
                if (position.y === cubeSize / 2) {
                    // No need to check for a cube below on the ground layer
                } else {
                    // For layers above the ground, a cube must be directly below.
                    if (!cubeBelow) {
                        return; // Prevents floating cubes
                    }
                    // And the color of the new cube must be different from the one below.
                    if (cubeBelow.data.color === color) {
                        return; // Same color on top is not allowed
                    }
                }
                
                const cubeGeometry = new THREE.BoxGeometry(cubeSize - 0.2, cubeSize - 0.2, cubeSize - 0.2);
                const materials = [
                    new THREE.MeshStandardMaterial({ color: color }),
                    new THREE.MeshStandardMaterial({ color: color }),
                    new THREE.MeshStandardMaterial({ color: color }),
                    new THREE.MeshStandardMaterial({ color: color }),
                    new THREE.MeshStandardMaterial({ color: color }),
                    new THREE.MeshStandardMaterial({ color: color }),
                ];
                const cubeMesh = new THREE.Mesh(cubeGeometry, materials);
                cubeMesh.position.copy(position);
                
                const edges = new THREE.EdgesGeometry(cubeGeometry);
                const wireframe = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 1 }));
                cubeMesh.add(wireframe);

                const cubeData = {
                    mesh: cubeMesh,
                    wireframe: wireframe,
                    data: {
                        position: position.clone(),
                        color: color
                    },
                    originalMaterial: materials
                };
                cubeContainer.add(cubeMesh);
                cubes.push(cubeData);
            }
            
            function getCubePositionsOnLine(startPos, endPos) {
                const positions = [];
                const deltaX = Math.abs(endPos.x - startPos.x);
                const deltaY = Math.abs(endPos.y - startPos.y);
                const deltaZ = Math.abs(endPos.z - startPos.z);
                const startX = startPos.x;
                const startY = startPos.y;
                const startZ = startPos.z;
                
                let primaryAxis = (is2DMode || deltaY === 0) ? (deltaX > deltaZ ? 'x' : 'z') : 'y';

                const getStep = (start, end) => (start < end) ? cubeSize : (start > end) ? -cubeSize : 0;
                let stepX = getStep(startX, endPos.x);
                let stepY = getStep(startY, endPos.y);
                let stepZ = getStep(startZ, endPos.z);

                if (primaryAxis !== 'x') stepX = 0;
                if (primaryAxis !== 'y') stepY = 0;
                if (primaryAxis !== 'z') stepZ = 0;

                const currentPos = startPos.clone();
                while (true) {
                    // Snapping logic with Math.floor for robustness
                    const snappedPos = new THREE.Vector3(
                        Math.floor(currentPos.x / cubeSize) * cubeSize + cubeSize / 2,
                        Math.floor(currentPos.y / cubeSize) * cubeSize + cubeSize / 2,
                        Math.floor(currentPos.z / cubeSize) * cubeSize + cubeSize / 2
                    );
                    positions.push(snappedPos);

                    if (currentPos.distanceTo(endPos) < 0.1) break;
                    
                    if (primaryAxis === 'x') currentPos.x += stepX;
                    if (primaryAxis === 'y') currentPos.y += stepY;
                    if (primaryAxis === 'z') currentPos.z += stepZ;
                    
                    const isBeyond = (primaryAxis === 'x' && ((stepX > 0 && currentPos.x > endPos.x) || (stepX < 0 && currentPos.x < endPos.x))) ||
                                     (primaryAxis === 'y' && ((stepY > 0 && currentPos.y > endPos.y) || (stepY < 0 && currentPos.y < endPos.y))) ||
                                     (primaryAxis === 'z' && ((stepZ > 0 && currentPos.z > endPos.z) || (stepZ < 0 && currentPos.z < endPos.z)));
                    if(isBeyond) {
                        currentPos.copy(endPos);
                    }
                }
                
                const uniquePositions = [];
                const positionSet = new Set();
                positions.forEach(pos => {
                    const key = `${pos.x},${pos.y},${pos.z}`;
                    if (!positionSet.has(key)) {
                        positionSet.add(key);
                        uniquePositions.push(pos);
                    }
                });

                return uniquePositions;
            }

            function getCubesInPath(startPos, endPos) {
                const positions = [];
                const direction = new THREE.Vector3().subVectors(endPos, startPos).normalize();
                const distance = startPos.distanceTo(endPos);
                
                for (let i = 0; i <= distance; i += cubeSize) {
                    const point = new THREE.Vector3().addVectors(startPos, direction.clone().multiplyScalar(i));
                    // Snapping logic with Math.floor for robustness
                    const snappedX = Math.floor(point.x / cubeSize) * cubeSize + cubeSize / 2;
                    const snappedY = Math.floor(point.y / cubeSize) * cubeSize + cubeSize / 2;
                    const snappedZ = Math.floor(point.z / cubeSize) * cubeSize + cubeSize / 2;
                    
                    const snappedPosition = new THREE.Vector3(snappedX, snappedY, snappedZ);
                    positions.push(snappedPosition);
                }

                const uniquePositions = [];
                const positionSet = new Set();
                positions.forEach(pos => {
                    const key = `${pos.x},${pos.y},${pos.z}`;
                    if (!positionSet.has(key)) {
                        positionSet.add(key);
                        uniquePositions.push(pos);
                    }
                });
                return uniquePositions;
            }


            function clearAllCubes() {
                while(cubes.length > 0) {
                    const cube = cubes.pop();
                    cubeContainer.remove(cube.mesh);
                }
            }
            
            function deleteCubeAt(position) {
                const cubeToDelete = cubes.find(c => c.mesh.position.distanceTo(position) < 0.1);
                if (cubeToDelete) {
                    cubeContainer.remove(cubeToDelete.mesh);
                    const index = cubes.indexOf(cubeToDelete);
                    if (index > -1) {
                        cubes.splice(index, 1);
                    }
                }
            }

            // --- Core Interaction Logic ---
            const plusSignBtn = document.getElementById('plus-sign');
            const minusSignBtn = document.getElementById('minus-sign');
            const clearAllBtn = document.getElementById('clear-all');

            function setMode(mode) {
                isPlacementMode = (mode === 'plus');
                isDeleteMode = (mode === 'minus');
                plusSignBtn.classList.toggle('active', isPlacementMode);
                minusSignBtn.classList.toggle('active', isDeleteMode);
                ghostPlacementMaterial.color.setHex(currentCubeColor);
                document.body.style.cursor = isPlacementMode ? 'copy' : 'crosshair';
            }
            
            plusSignBtn.addEventListener('click', () => setMode('plus'));
            minusSignBtn.addEventListener('click', () => setMode('minus'));

            clearAllBtn.addEventListener('click', () => {
                clearAllCubes();
                setMode('plus');
                document.body.style.cursor = 'copy';
            });
            
            setMode('plus');

            const colors = {
                'color-red': 0xFF0000,
                'color-yellow': 0xFFFF00,
                'color-blue': 0x0000FF,
                'color-green': 0x00FF00,
                'color-orange': 0xFFA500,
                'color-purple': 0x800080
            };
            const colorButtons = document.querySelectorAll('.color-button');
            colorButtons.forEach(button => {
                button.addEventListener('click', () => {
                    colorButtons.forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    currentCubeColor = colors[button.id];
                    ghostPlacementMaterial.color.setHex(currentCubeColor);
                });
            });

            document.getElementById('color-red').click();

            function getIntersectionPoint(event) {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, camera);

                const cubeIntersects = raycaster.intersectObjects(cubeContainer.children);
                const groundIntersects = raycaster.intersectObjects([groundPlane]);
                
                let newPos = null;

                if (cubeIntersects.length > 0) {
                    const intersectedObject = cubeIntersects[0].object;
                    const normal = cubeIntersects[0].face.normal.clone().normalize();
                    newPos = new THREE.Vector3().addVectors(intersectedObject.getWorldPosition(new THREE.Vector3()), normal.multiplyScalar(cubeSize));
                } else if (groundIntersects.length > 0) {
                    const hitPoint = groundIntersects[0].point;
                    newPos = new THREE.Vector3(hitPoint.x, cubeSize / 2, hitPoint.z);
                }
                
                if (newPos) {
                    // This is the updated snapping logic
                    const snappedX = Math.floor(newPos.x / cubeSize) * cubeSize + cubeSize / 2;
                    const snappedY = Math.floor(newPos.y / cubeSize) * cubeSize + cubeSize / 2;
                    const snappedZ = Math.floor(newPos.z / cubeSize) * cubeSize + cubeSize / 2;
                    return new THREE.Vector3(snappedX, snappedY, snappedZ);
                }
                return null;
            }

            function clearGhostLine() {
                while(ghostLineGroup.children.length > 0) {
                    ghostLineGroup.remove(ghostLineGroup.children[0]);
                }
            }

            function updateGhostLine(startPos, endPos) {
                clearGhostLine();
                const positions = getCubePositionsOnLine(startPos, endPos);
                positions.forEach(pos => {
                    const ghostCube = new THREE.Mesh(ghostGeometry, ghostPlacementMaterial);
                    ghostCube.position.copy(pos);
                    ghostLineGroup.add(ghostCube);
                });
            }

            renderer.domElement.addEventListener('mousemove', (event) => {
                if (isDraggingCamera) {
                    const deltaX = event.clientX - previousMousePosition.x;
                    const deltaY = event.clientY - previousMousePosition.y;
                    const target = new THREE.Vector3();
                    camera.getWorldDirection(target);
                    const right = new THREE.Vector3().crossVectors(camera.up, target);
                    const up = new THREE.Vector3().crossVectors(target, right);
                    const yawRotation = new THREE.Quaternion().setFromAxisAngle(up, deltaX * -0.01);
                    const pitchRotation = new THREE.Quaternion().setFromAxisAngle(right, deltaY * 0.01);
                    const finalRotation = new THREE.Quaternion().multiplyQuaternions(pitchRotation, yawRotation);
                    const rotatedPosition = new THREE.Vector3().copy(camera.position).applyQuaternion(finalRotation);
                    camera.position.copy(rotatedPosition);
                    camera.lookAt(0, 0, 0);
                    previousMousePosition.x = event.clientX;
                    previousMousePosition.y = event.clientY;
                    return;
                }

                const mousePos = getIntersectionPoint(event);
                if (!mousePos) {
                    ghostLineGroup.visible = false;
                    ghostCube.visible = false;
                    return;
                }

                if (isDragging) {
                    if (isShiftDragging) {
                        updateGhostLine(dragStartPoint, mousePos);
                        ghostLineGroup.visible = true;
                        ghostCube.visible = false;
                    } else {
                        if (lastDraggedPosition && mousePos.distanceTo(lastDraggedPosition) > 0.1) {
                            const positions = getCubesInPath(lastDraggedPosition, mousePos);
                            positions.forEach(pos => {
                                if (isPlacementMode) {
                                    createCube(pos);
                                } else if (isDeleteMode) {
                                    deleteCubeAt(pos);
                                }
                            });
                            lastDraggedPosition = mousePos.clone();
                        }
                        ghostCubePosition.copy(mousePos);
                        ghostCube.position.copy(ghostCubePosition);
                        ghostCube.visible = true;
                        clearGhostLine();
                    }
                } else {
                    clearGhostLine();
                    ghostCubePosition.copy(mousePos);
                    ghostCube.position.copy(ghostCubePosition);
                    ghostCube.visible = true;
                }
            });

            renderer.domElement.addEventListener('mousedown', (event) => {
                if (event.target.tagName.toLowerCase() !== 'canvas') {
                    return;
                }
                
                isDragging = true;
                isShiftDragging = event.shiftKey;
                isDraggingCamera = event.shiftKey && !isPlacementMode && !isDeleteMode && !is2DMode;
                if (isDraggingCamera) {
                    previousMousePosition.x = event.clientX;
                    previousMousePosition.y = event.clientY;
                    document.body.style.cursor = 'grabbing';
                } else {
                    dragStartPoint = getIntersectionPoint(event);
                    if (!isShiftDragging && dragStartPoint) {
                        if (isPlacementMode) {
                            createCube(dragStartPoint);
                        } else if (isDeleteMode) {
                            deleteCubeAt(dragStartPoint);
                        }
                        lastDraggedPosition = dragStartPoint.clone();
                    }
                }
            });

            renderer.domElement.addEventListener('mouseup', (event) => {
                if (isDragging && isShiftDragging && dragStartPoint) {
                    const dragEndPoint = getIntersectionPoint(event);
                    if (dragEndPoint) {
                        const positions = getCubePositionsOnLine(dragStartPoint, dragEndPoint);
                        positions.forEach(pos => {
                            if (isPlacementMode) {
                                createCube(pos);
                            } else {
                                deleteCubeAt(pos);
                            }
                        });
                    }
                }
                isDragging = false;
                isShiftDragging = false;
                isDraggingCamera = false;
                dragStartPoint = null;
                lastDraggedPosition = null;
                clearGhostLine();
                document.body.style.cursor = isPlacementMode ? 'copy' : 'crosshair';
            });

            renderer.domElement.addEventListener('click', (event) => {
                if (!isDragging && !event.shiftKey && ghostCube.visible) {
                    if (isPlacementMode) {
                        createCube(ghostCubePosition);
                    } else if (isDeleteMode) {
                        deleteCubeAt(ghostCubePosition);
                    }
                }
            });

            window.addEventListener('keydown', (event) => {
                let moved = false;
                const newPos = ghostCubePosition.clone();
                if (event.ctrlKey || event.metaKey) {
                    if (event.key === 'c' || event.key === 'C') {
                        const cubeToCopy = cubes.find(c => c.mesh.getWorldPosition(new THREE.Vector3()).distanceTo(ghostCubePosition) < 0.1);
                        if (cubeToCopy) {
                            clipboard = { color: cubeToCopy.data.color };
                        }
                    } else if (event.key === 'x' || event.key === 'X') {
                        const cubeToCut = cubes.find(c => c.mesh.getWorldPosition(new THREE.Vector3()).distanceTo(ghostCubePosition) < 0.1);
                        if (cubeToCut) {
                            clipboard = { color: cubeToCut.data.color };
                            deleteCubeAt(ghostCubePosition);
                        }
                    } else if (event.key === 'v' || event.key === 'V') {
                        if (clipboard) {
                            createCube(ghostCubePosition, clipboard.color);
                        }
                    }
                } else {
                    switch(event.key) {
                        case 'ArrowUp':
                            newPos.z -= cubeSize;
                            moved = true;
                            break;
                        case 'ArrowDown':
                            newPos.z += cubeSize;
                            moved = true;
                            break;
                        case 'ArrowLeft':
                            newPos.x -= cubeSize;
                            moved = true;
                            break;
                        case 'ArrowRight':
                            newPos.x += cubeSize;
                            moved = true;
                            break;
                        case '+':
                            camera.translateZ(-3);
                            break;
                        case '-':
                            camera.translateZ(3);
                            break;
                        case ' ':
                        case 'Enter':
                            if (isPlacementMode) {
                                createCube(ghostCubePosition);
                            } else if (isDeleteMode) {
                                deleteCubeAt(ghostCubePosition);
                            }
                            event.preventDefault();
                            break;
                    }
                }

                if (moved) {
                    const withinBounds = Math.abs(newPos.x) <= MAX_GRID_POS &&
                                         newPos.y <= MAX_HEIGHT_POS && newPos.y >= cubeSize / 2 &&
                                         Math.abs(newPos.z) <= MAX_GRID_POS;
                    if (withinBounds) {
                        ghostCubePosition.copy(newPos);
                        ghostCube.position.copy(ghostCubePosition);
                        ghostCube.visible = true;
                    }
                }
            });
            
            const zoomInBtn = document.getElementById('zoom-in');
            const zoomOutBtn = document.getElementById('zoom-out');
            const view2DBtn = document.getElementById('view-2d');
            const view3DBtn = document.getElementById('view-3d');
            
            function setViewMode(mode) {
                is2DMode = (mode === '2d');
                view2DBtn.classList.toggle('active', is2DMode);
                view3DBtn.classList.toggle('active', !is2DMode);

                if (is2DMode) {
                    camera.position.copy(topDownCameraPosition);
                    camera.lookAt(0, 0, 0);
                } else {
                    camera.position.copy(default3DCameraPosition);
                    camera.lookAt(0, 0, 0);
                }
            }

            view2DBtn.addEventListener('click', () => setViewMode('2d'));
            view3DBtn.addEventListener('click', () => setViewMode('3d'));

            zoomInBtn.addEventListener('click', () => {
                camera.translateZ(-3);
            });

            zoomOutBtn.addEventListener('click', () => {
                camera.translateZ(3);
            });
            
            function animate() {
                requestAnimationFrame(animate);
                renderer.render(scene, camera);
            }

            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 20, 10);
            scene.add(directionalLight);

            animate();

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        };
    </script>
</body>
</html>
